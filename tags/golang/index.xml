<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on Peyton Walters</title>
    <link>https://pawalt.github.io/tags/golang/</link>
    <description>Recent content in golang on Peyton Walters</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Peyton Walters</copyright>
    <lastBuildDate>Sun, 07 Jul 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://pawalt.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Caplance Development Update 3</title>
      <link>https://pawalt.github.io/posts/2019/07/caplance-development-update-3/</link>
      <pubDate>Sun, 07 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://pawalt.github.io/posts/2019/07/caplance-development-update-3/</guid>
      <description>ðŸŽ‰ We made it! ðŸŽ‰ After 6 months of work, Caplance is finally at MVP. The brief release notes can be found here.
To get to MVP, I had to implement the following functionality:
 Logging Config file parsing  Combining all the previous updates, we get the following feature set for the MVP:
 Packet listening Packet forwarding over UDP Direct reply from backends, allowing the load balancer to only have to handle incoming traffic Dynamic backend registration and deregistration Backend commands and health checks Logging Config file parsing  I&amp;rsquo;ll briefly cover the improvements so far and then give a short demo of Caplance working.</description>
    </item>
    
    <item>
      <title>Caplance Development Update 2</title>
      <link>https://pawalt.github.io/posts/2019/06/caplance-development-update-2/</link>
      <pubDate>Sun, 30 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://pawalt.github.io/posts/2019/06/caplance-development-update-2/</guid>
      <description>I&amp;rsquo;m back! Over the past few weeks, I&amp;rsquo;ve had much more time to work on Caplance than I had in the prior months, so, naturally, a ton of work has gotten done in these few weeks. Specifically, I&amp;rsquo;ve implemented the following functionality:
 Backend registration The following controls from the backends:  PAUSE DEREGISTER RESUME HEALTH  caplancectl to tell a running client process to issue one of those commands Graceful stop for backends Packet listening on NFQUEUE Refactor project structure  If you&amp;rsquo;ve been keeping track, you&amp;rsquo;ll notice that this puts us very close to the Caplance MVP!</description>
    </item>
    
    <item>
      <title>My Neovim Go Setup</title>
      <link>https://pawalt.github.io/posts/2019/06/my-neovim-go-setup/</link>
      <pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://pawalt.github.io/posts/2019/06/my-neovim-go-setup/</guid>
      <description>Recently, I moved from writing my Go in VSCode to writing it in Neovim. I did this for two main reasons:
 Ubiquity
I use Neovim for writing pretty much all my other code (except Java), so it was weird to use VSCode for this one purpose.
 Terminal Integration
I hate the VS Code terminal. It doesn&amp;rsquo;t have the character support I want, and it overrides a bunch of keys (for example, Ctrl+f for fish autocomplete).</description>
    </item>
    
    <item>
      <title>Caplance Development Update 1</title>
      <link>https://pawalt.github.io/posts/2019/05/caplance-development-update-1/</link>
      <pubDate>Sat, 25 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://pawalt.github.io/posts/2019/05/caplance-development-update-1/</guid>
      <description>After countless hours spent reading the GoDocs, googling &amp;ldquo;gre packets golang&amp;rdquo;, and staring at the term SIGSEV, I&amp;rsquo;ve got an update! I&amp;rsquo;ve made pretty significant progress on the actual load balancer, implementing most of the base functionality. So far, the load balancer can:
 listen for and ingest whole IP packets select the backend for a packet based on a combination of IP and source port encapsulate packets in UDP and send them to the appropriate backend attach a specified virtual IP  I&amp;rsquo;ve also implemented some extremely rudimentary testing and setup, but I&amp;rsquo;m going to rework those once the project structure solidifies some more.</description>
    </item>
    
    <item>
      <title>Hacking Farkle</title>
      <link>https://pawalt.github.io/posts/2018/12/hacking-farkle/</link>
      <pubDate>Sat, 29 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pawalt.github.io/posts/2018/12/hacking-farkle/</guid>
      <description>Recently, my family has been playing Farkle, a simple but difficult-to-analyze dice game. Farkle has the following rules:
 At the start of the turn, each player must roll the 6 dice. After rolling, the player sets aside all the dice that scored. The player can then choose to roll again to potentially get more points or to take the points they have already scored. If the player rolls and scores no points, they get 0 points and their turn is over.</description>
    </item>
    
  </channel>
</rss>